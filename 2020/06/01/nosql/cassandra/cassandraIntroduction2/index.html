<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>cassandraIntroduction2 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Cassandra是什么？Cassandra是一种开源的、基于键值(key、value)对的、去中心化的、易于扩展的分布式nosql数据库。   该开源项目在github上的定义如下:Apache Cassandra is a highly-scalable partitioned row store. Rows are organized into tables with a required">
<meta property="og:type" content="article">
<meta property="og:title" content="cassandraIntroduction2">
<meta property="og:url" content="http://yoursite.com/2020/06/01/nosql/cassandra/cassandraIntroduction2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Cassandra是什么？Cassandra是一种开源的、基于键值(key、value)对的、去中心化的、易于扩展的分布式nosql数据库。   该开源项目在github上的定义如下:Apache Cassandra is a highly-scalable partitioned row store. Rows are organized into tables with a required">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://yoursite.com/Users/zhouqingfeng/Desktop/myDirect/github/distributedStudy/nosql/cassandra/dataRing.png">
<meta property="og:image" content="http://yoursite.com/Users/zhouqingfeng/Desktop/myDirect/github/distributedStudy/nosql/cassandra/token%E5%88%86%E5%B8%83.png">
<meta property="article:published_time" content="2020-06-01T10:02:14.000Z">
<meta property="article:modified_time" content="2020-06-01T10:02:47.304Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/Users/zhouqingfeng/Desktop/myDirect/github/distributedStudy/nosql/cassandra/dataRing.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-nosql/cassandra/cassandraIntroduction2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/01/nosql/cassandra/cassandraIntroduction2/" class="article-date">
  <time datetime="2020-06-01T10:02:14.000Z" itemprop="datePublished">2020-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      cassandraIntroduction2
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Cassandra是什么？"><a href="#Cassandra是什么？" class="headerlink" title="Cassandra是什么？"></a>Cassandra是什么？</h2><p>Cassandra是一种开源的、基于键值(key、value)对的、去中心化的、易于扩展的分布式nosql数据库。  </p>
<h3 id="该开源项目在github上的定义如下"><a href="#该开源项目在github上的定义如下" class="headerlink" title="该开源项目在github上的定义如下:"></a>该开源项目在github上的定义如下:</h3><p>Apache Cassandra is a highly-scalable partitioned row store. Rows are organized into tables with a required primary key.<br>Partitioning means that Cassandra can distribute your data across multiple machines in an application-transparent matter. Cassandra will automatically repartition as machines are added and removed from the cluster.<br>Row store means that like relational databases, Cassandra organizes data by rows and columns. The Cassandra Query Language (CQL) is a close relative of SQL.<br>Cassandra是一种可高度扩展的、数据可自动分区、对数据按行列组织的存储系统。行(row)必须含有主键, 按行将数据组织成(不同的)表。这里数据分区指的是:Cassandra以一种对应用完全透明的方式(各种应用在程序里无需显示指定)将数据分布式存储在多台机器节点上。当对集群添加或删除机器(节点)时, (数据会)自动重分区,(完成数据迁移)。 行存储(row store)指的是: Cassandra采用和关系型数据库同样的方式, 按行列组织数据。 cql(全称Cassandra Query Language)是一种和sql非常相近的(数据库)查询语言。  </p>
<h3 id="cassandra历史-wiki"><a href="#cassandra历史-wiki" class="headerlink" title="cassandra历史(wiki):"></a>cassandra历史(wiki):</h3><p>Avinash Lakshman, one of the authors of Amazon’s Dynamo, and Prashant Malik initially developed Cassandra at Facebook to power the Facebook inbox search feature(message消息搜索). Facebook released Cassandra as an open-source project on Google code in July 2008.On February 17, 2010 it graduated to a top-level project.<br>Facebook 的开发工程师将数据库命名为Cassandra([kə’sændrə],表示不为人所信的预言家, 对应的是希腊神话故事中的一个人物: In Greek mythology, Cassandra (Greek: Κασσάνδρα, pronounced [kas̚sándra͜a], also Κασάνδρα), also known as Alexandra or Kassandra, was the daughter of King Priam and Queen Hecuba of Troy.A common version of her story is that Apollo gave her the power of prophecy in order to seduce her, but when she refused him, he gave her the curse of never being believed. Cassandra是国王和王后的女儿，为了引诱她，阿波罗赠与她预言的能力，但是被她拒绝了，因此被诅咒永远不被人所相信。)  </p>
<h3 id="各版本-Releases-变动情况如下"><a href="#各版本-Releases-变动情况如下" class="headerlink" title="各版本(Releases)变动情况如下:"></a>各版本(Releases)变动情况如下:</h3><p>0.6, released Apr 12 2010, added support for integrated caching, and Apache Hadoop MapReduce[6]<br>0.7, released Jan 08 2011, added secondary indexes and online schema changes[7]<br>0.8, released Jun 2 2011, added the Cassandra Query Language (CQL), self-tuning memtables, and support for zero-downtime upgrades[8]<br>1.0, released Oct 17 2011, added integrated compression, leveled compaction, and improved read-performance[9]<br>1.1, released Apr 23 2012, added self-tuning caches, row-level isolation, and support for mixed ssd/spinning disk deployments[10]<br>1.2, released Jan 2 2013, added clustering across virtual nodes, inter-node communication, atomic batches, and request tracing[11]<br>2.0, released September 4, 2013; 4 years ago, added lightweight transactions (based on the Paxos consensus protocol), triggers, improved compactions<br>2.1 released Sep 10 2014 [12]<br>2.2 released July 20, 2015<br>3.0 released November 11, 2015<br>3.1 through 3.10 releases were monthly releases using a tick-tock-like release model, with even-numbered releases providing both new features and bug fixes while odd-numbered releases will include bug fixes only.<br>3.11 released June 23, 2017 as a stable 3.11 release series and bug fix from the last tick-tock feature release.<br>Apache Cassandra is a free and open-source distributed wide column store NoSQL database management system designed to handle large amounts of data across many commodity servers, providing high availability with no single point of failure. Cassandra offers robust support for clusters spanning multiple datacenters,[1] with asynchronous masterless replication allowing low latency operations for all clients.<br><strong>wiki定义翻译</strong>: Cassandra是一种免费开源的、分布式的、宽列存储(wide column store)的nosql数据库管理系统。旨在通过使用许多廉价PC机(commodity server是常用服务器, commodity是商品、日用品的意思, 猜测大致意思应该就是 常用的性能很一般的机器)处理大量数据, (同时借助)无单点故障(p2p架构, 集群采用去中心化结构, 无master节点, 即使有单个节点发生故障无法对外提供服务时,整个集群对外服务表现仍然是正常的, client基本上是无法感知到的)提供高可用性。对与跨多个数据中心的集群，Cassandra提供了强有力(稳健的)的支撑,考虑到允许客户端低延时操作,（因而其)采用了异步的非中心化(masterless，去master)的复制机制.<br><strong>当前市场(部分来自wiki),<a href="https://www.datastax.com" target="_blank" rel="noopener">datastax</a>公司已经将该数据库商业化经营, 大公司使用情况列举如下:</strong>   </p>
<ul>
<li>ebay(一家美国电商, 起步远早于阿里, 后退出中国市场, 淘宝模仿了ebay, 支付宝aliPay模仿了ebay的Paypal)<a href="https://www.datastax.com/wp-content/uploads/2012/08/C2012-BuyItNow-JayPatel.pdf" target="_blank" rel="noopener">Cassandra at eBay - DataStax</a>  </li>
<li>Facebook有一部分业务, 目前应该还在用(来自网络)  </li>
<li>Apple uses 100,000 Cassandra nodes, as revealed at Cassandra Summit San Francisco 2015, although it has not elaborated for which products, services or features  </li>
<li>Cisco’s WebEx uses Cassandra to store user feed and activity in near real time  </li>
<li>Netflix uses Cassandra as their back-end database for their streaming services  </li>
<li>Uber uses Cassandra to store around 10,000 features in their daily updated company-wide Feature Store for low-latency access during live model predictions    </li>
<li>在<a href="https://db-engines.com/en/ranking" target="_blank" rel="noopener">db-engines</a>上, Cassandra一直排名前十, 远高于hbase. <strong>国内由于各种原因, HBASE的使用率却远高于Cassandra</strong>(一部分原因可能是hbase和hadoop生态圈结合的更紧密一些, HBASE的数据直接存储在HDFS上, 不需要有另外一套新的存储磁盘等). 据了解, 360公司目前在用.  </li>
</ul>
<h2 id="Some-features（特点"><a href="#Some-features（特点" class="headerlink" title="Some features（特点):"></a>Some features（特点):</h2><h3 id="wide-column-store-wiki定义-key-value存储"><a href="#wide-column-store-wiki定义-key-value存储" class="headerlink" title="wide column store wiki定义(key value存储):"></a>wide column store wiki定义(key value存储):</h3><p>A wide column store is a type of NoSQL database. It uses tables, rows, and columns, but unlike a relational database, the names and format of the columns can vary from row to row in the same table. <strong>A wide column store can be interpreted as a two-dimensional key-value store.[1]</strong>  </p>
<p>As such two-level structures do not use a columnar data layout, wide column stores such as Bigtable and Apache Cassandra are not column stores in the original sense of the term. In genuine column stores, a columnar data layout is adopted such that each column is stored separately on disk. W<strong>ide column stores do often support the notion of column families that are stored separately</strong>. However, each such column family typically contains multiple columns that are used together, similar to traditional relational database tables. Within a given column family, all data is stored in a row-by-row fashion, such that the columns for a given row are stored together, rather than each column being stored separately. Wide column stores that support column families are also known as column family databases.</p>
<p><strong>wide column store wiki简单翻译</strong>：宽列存储(wide column stores)既是二维的key-value存储。Bigtable和Cassandra都是宽列存储, 但是他们并非列式存储(column store). 在真正意义上的列式存储中, 每一列被单独的存储在磁盘上。而在宽列存储中，多个列组成列族(column family), 一个列族内部，数据按行进行存储。(一个大表通常含有)多个列族, 每个列族被分开存储在磁盘上。 这里申明一下：<strong>在Cassandra里, keyspace其实是一个大表(big table 同时管理了多个column family), 一个column family就是一个table, 用户可以随时自定义添加或删除多个table(column famil), 相比于hbase 更加灵活, hbase的table就对应的是Cassandra的keyspace, HBASE必须在建表时指定多个列族(column family), 后面(似乎不能)随意添加或删除列族</strong>。</p>
<h3 id="Distributed"><a href="#Distributed" class="headerlink" title="Distributed"></a>Distributed</h3><p>Every node in the cluster has the same role. There is no single point of failure. Data is distributed across the cluster (so each node contains different data), but there is no master as every node can service any request. (p2p架构，节点角色无master\slave之分)所有节点具有相同的角色，无单点故障。数据分布式存储在集群的不同的节点上，由于无master节点因此每一个节点可以处理任何请求。  </p>
<h3 id="Supports-replication-and-multi-data-center-replication"><a href="#Supports-replication-and-multi-data-center-replication" class="headerlink" title="Supports replication and multi data center replication"></a>Supports replication and multi data center replication</h3><p>Replication strategies are configurable.[15] Cassandra is designed as a distributed system, for deployment of large numbers of nodes across multiple data centers. Key features of Cassandra’s distributed architecture are specifically tailored for multiple-data center deployment, for redundancy, for failover and disaster recovery.<br>副本策略是可配置的。作为一种分布式系统，可以在多个数据中心部署大量的节点。其分布式架构的主要特点使其特别适合于多数据中心部署、数据冗余(配置数据副本策略实现)、故障转移和灾难恢复。</p>
<h3 id="Scalability"><a href="#Scalability" class="headerlink" title="Scalability"></a>Scalability</h3><p>Designed to have read and write throughput both increase linearly as new machines are added, with the aim of no downtime or interruption to applications.(增加新的节点时， 读写吞吐量都会线性增加，但是(当新的节点加入时，原有的已经部署的)应用不需要下线(downtime 指停工或停机)或中断)。  </p>
<h3 id="Fault-tolerant"><a href="#Fault-tolerant" class="headerlink" title="Fault-tolerant"></a>Fault-tolerant</h3><p>Data is automatically replicated to multiple nodes for fault-tolerance. Replication across multiple data centers is supported. Failed nodes can be replaced with no downtime.  (副本机制用于)容错，一份数据被复制存储在多个节点上。(发生故障)的失效节点可以被替换掉。</p>
<h3 id="Tunable-consistency"><a href="#Tunable-consistency" class="headerlink" title="Tunable consistency"></a>Tunable consistency</h3><p>Cassandra is typically classified as an AP system, meaning that availability and partition tolerance are generally considered to be more important than consistency in Cassandra[16], Writes and reads offer a tunable level of consistency, all the way from “writes never fail” to “block for all replicas to be readable”, with the quorum level in the middle.<br>Cassandra是一种典型的AP系统(即满足分布式系统CAP特性的AP), 意味着 通常来说系统可靠性和分区容错性 考虑地 比一致性更重要. 但是, 其读写提供了一种可以调节的一致性：就是说用户应用 在读写数据时，可以设置一致性级别：one、two、quorum、all等. one表示只要有一个节点数据可用，就对用户的request返回一个response; two表示至少需要有两个副本节点数据可用并且数据一致，就对用户的request返回一个response; quorum表示需要有超过一半的存储数据的节点 数据可用并且数据一致，就对用户的request返回一个response; all表示需要所有的存储数据的节点 数据可用并且数据一致。 This is a concrete document from datastax.com, about <a href="https://docs.datastax.com/en/archived/cassandra/3.x/cassandra/dml/dmlConfigConsistency.html?hl=consistency" target="_blank" rel="noopener">how to configure read or write consistency level with cassandra</a>?  </p>
<h3 id="MapReduce-support"><a href="#MapReduce-support" class="headerlink" title="MapReduce support"></a>MapReduce support</h3><p>Cassandra has Hadoop integration, with MapReduce support. There is support also for Apache Pig and Apache Hive. 其可以和Hadoop进行整合, 支持MapReduce.    </p>
<h3 id="Cassandra-Query-Language-CQL"><a href="#Cassandra-Query-Language-CQL" class="headerlink" title="Cassandra Query Language(CQL)"></a>Cassandra Query Language(CQL)</h3><p>Cassandra introduced the Cassandra Query Language (CQL). CQL is a simple interface for accessing Cassandra, as an alternative to the traditional Structured Query Language (SQL). CQL adds an abstraction layer that hides implementation details of this structure and provides native syntaxes for collections and other common encodings. Language drivers are available for Java (JDBC), Python (DBAPI2), Node.JS (Helenus), Go (gocql) and C++.[19]<br>CQL是访问Cassandra的一种简单的接口, 类似于结构化查询语言SQL. CQL添加了一个抽象层, 隐藏了底层结构的实现细节并且提供了对于集合和其它公共编码的本地语法支持。JAVA、python、node.js、go、c++都可以借助cql对集群进行访问。  </p>
<p>Below an example of keyspace creation, including a column family in CQL 3.0:<br>以下实例, 创建了一个keyspace: MyKeySpace, 同时创建了一个table，即一个COLUMN FAMILY：MyColumns，之后插入了一条数据。<br>CREATE KEYSPACE MyKeySpace<br>  WITH REPLICATION = { ‘class’ : ‘SimpleStrategy’, ‘replication_factor’ : 3 };</p>
<p>USE MyKeySpace;</p>
<p>CREATE COLUMNFAMILY MyColumns (id text, Last text, First text, PRIMARY KEY(id));<br>等价于 CREATE TABLE MyColumns (id text, Last text, First text, PRIMARY KEY(id));</p>
<p>INSERT INTO MyColumns (id, Last, First) VALUES (‘1’, ‘Doe’, ‘John’);</p>
<p>SELECT * FROM MyColumns;  </p>
<h2 id="Data-model-数据模型"><a href="#Data-model-数据模型" class="headerlink" title="Data model(数据模型)"></a>Data model(数据模型)</h2><p>数据划分为多个keyspace存储, 一个keyspace又包含多个column family(column family is also called table in CQL3.0)。Internally, Each Column Families are stored in separate files on disk, 准确地说, 应该是不同的列族存储在不同的磁盘文件目录里。 一个table按照行列组织数据，每一行由主键唯一确定(each row is identified by a primary key).<strong>primary key由两部分组成：partition key和cluster key</strong>. 其中partition key(可以含有多列,即组合分区建)决定了第一份写入的数据存储在哪一台节点上, cluster key(可以含有多个column, column从前往后按指定顺序排序)决定了 含有相同partition key的多行数据是如何排序的。</p>
<p>Cassandra cannot do joins or subqueries. Rather, Cassandra emphasizes denormalization through features like collections.<br>Cassandra 不支持join和子查询。 强调反范式，通过使用一些特征，比如集合。</p>
<p><strong>关于data Clustered</strong>, <a href="https://en.wikipedia.org/wiki/Database_index#Clustered" target="_blank" rel="noopener">wiki的解释</a><br>Clustering alters the data block into a certain distinct order to match the index, resulting in the row data being stored in order. Therefore, only one clustered index can be created on a given database table. Clustered indices can greatly increase overall speed of retrieval, but usually only where the data is accessed sequentially in the same or reverse order of the clustered index, or when a range of items is selected.<br>clustering使row data有序排列。  </p>
<p>Since the physical records are in this sort order on disk, the next row item in the sequence is immediately before or after the last one, and so fewer data block reads are required. The primary feature of a clustered index is therefore the ordering of the physical data rows in accordance with the index blocks that point to them. Some databases separate the data and index blocks into separate files, others put two completely different data blocks within the same physical file(s).<br>物理存储的record记录在磁盘上也是按照cluster key的顺序进行存储。 </p>
<p><strong>关于clumn family</strong>,<a href="https://en.wikipedia.org/wiki/Apache_Cassandra" target="_blank" rel="noopener">wiki的解释</a><br>A column family (called “table” since CQL 3) resembles a table in an RDBMS. Column families contain rows and columns. Each row is uniquely identified by a row key. Each row has multiple columns, each of which has a name, value, and a timestamp. Unlike a table in an RDBMS, different rows in the same column family do not have to share the same set of columns, and a column may be added to one or multiple rows at any time<br>在同一个列族的不同行可以含有不同的列集合，在任何时候可以在一行或者多行数据中添加一列。  </p>
<p><strong>当用户向table中insert一条数据后,数据是如何分布式存储的(这里暂时不考虑其他副本, 只考虑第一份数据，也即是第一个副本)</strong>, 这里主要涉及到<strong>partitioner、vnode、token</strong>的概念。<br><strong>partitioner:</strong> A partitioner determines how data is distributed across the nodes in the cluster (including replicas). Basically, a partitioner is a function for deriving a token representing a row from its partition key, typically by hashing. Each row of data is then distributed across the cluster by the value of the token。Partitioner决定了数据是如何在集群中的多个节点上分布的。本质上说, partitioner是一个函数, 它根据partition key计算获取到一个token值, 通常通过hash计算。每一行的数据根据这个计算得到的token值在集群上分布式存储。<br>3.9版本中提到了两种Partitioner: RandomPartitioner 和 Murmur3Partitioner.<br><a href="https://docs.datastax.com/en/archived/cassandra/3.x/cassandra/architecture/archPartitionerM3P.html" target="_blank" rel="noopener">Murmur3Partitioner</a>：The Murmur3Partitioner is the default partitioning strategy for Cassandra 1.2 and later new clusters and the right choice for new clusters in almost all cases. The Murmur3Partitioner provides faster hashing and improved performance than the RandomPartitioner. The Murmur3Partitioner can be used with vnodes.  The Murmur3Partitioner uses the MurmurHash function. This hashing function creates a 64-bit hash value of the partition key. The possible range of hash values is from -263 to +263-1( 也就是说通过这种方法计算得到的token值的范围是正负2的63次方, 总共的token值可以有2的64次方个)<br><a href="https://docs.datastax.com/en/archived/cassandra/3.x/cassandra/architecture/archPartitionerRandom.html" target="_blank" rel="noopener">RandomPartitioner</a>:The RandomPartitioner was the default partitioner prior to Cassandra 1.2.RandomPartitioner distributes data evenly across the nodes using an MD5 hash value of the row key. The possible range of hash values is from 0 to 2的127次方 -1.（使用了md5算法计算hash值. <a href="http://www.ningoo.net/html/2010/cassandra_token.html" target="_blank" rel="noopener">使用详解</a>）  </p>
<p><strong>关于Vnode:</strong><br><strong>1.2版本之前, 并没有vnode的概念, 1.2之后才引入</strong>。<br>Prior to Cassandra 1.2, you had to calculate and assign a single token to each node in a cluster. Each token determined the node’s position in the ring and its portion of data according to its hash value.<br>1.2版本之前, 集群每一个节点含有一个token(必须手动计算并将计算后的token值分配给每一个节点)。每一个token决定了节点在数据环中的位置, 也就是每个节点存储了数据环中的哪一部分数据。由于Cassandra的节点无主从之分, 节点之间的相互关系是对等的, 每个节点都会存储一部分数据, 这样从整体来看, 整体数据存储就形成了一个<strong>数据环</strong>, 每个节点都会对应数据环中的一部分数据。1.2版本之前, 每个节点对应一个token值, 实际对应存储的一段连续范围内(token连续)的数据。就是说, partitioner根据partition key 计算得到一个token, 如果该token 在某个节点对应的token值表示的数据范围内, 就将相应数据存储在该节点上。<br><a href="https://docs.datastax.com/en/archived/cassandra/3.x/cassandra/architecture/archDataDistributeDistribute.html" target="_blank" rel="noopener">如下表示一个典型的数据环，解释了数据是如何在集群的多个node上分布式存储的</a>:<br><img src="/Users/zhouqingfeng/Desktop/myDirect/github/distributedStudy/nosql/cassandra/dataRing.png" alt="cassandra data ring"> </p>
<p><strong>解释说明</strong>：<br>The top portion of the graphic shows a cluster without vnodes. In this paradigm, each node is assigned a single token that represents a location in the ring. Each node stores data determined by mapping the partition key to a token value within a range from the previous node to its assigned value. Each node also contains copies of each row from other nodes in the cluster. For example, if the replication factor is 3, range E replicates to nodes 5, 6, and 1. Notice that a node owns exactly one contiguous partition range in the ring space.  图中第一部分展示了不含vnode的集群。每个节点除了包含指定token范围的数据外, 也含有来自其他节点的副本数据。图例中, 含有6个节点, 数据被分为连续的6段分别存储在每个节点上。由于设置了副本因子为3，range E(一段数据, 对应一个token)存储在节点5上, 其他两个副本分别存储在节点6和节点1上。图中明显可以看出：每个节点仅仅含有数据环中的一段连续范围内的数据。<br><a href="https://docs.datastax.com/en/archived/cassandra/1.1/docs/initialize/token_generation.html" target="_blank" rel="noopener">1.2版本之前, 如何产生token以及token分布:Generating Tokens</a>:<br>Tokens assign a range of data to a particular node within a data center.<br>When you start a Cassandra cluster, data is distributed across the nodes in the cluster based on the row key using a partitioner. You must assign each node in a cluster a token and that token determines the node’s position in the ring and its range of data. The tokens assigned to your nodes need to be distributed throughout the entire possible range of tokens (0 to 2127 -1). Each node is responsible for the region of the ring between itself (inclusive) and its predecessor (exclusive). To illustrate using a simple example, if the range of possible tokens was 0 to 100 and you had four nodes, the tokens for your nodes should be 0, 25, 50, and 75. This approach ensures that each node is responsible for an equal range of data. When using more than one data center, each data center should be partitioned as if it were its own distinct ring. 这里说的是, 每个节点对应的是ring的一部分数据(前并后开)。例子:一个集群含有4个节点, 对应的token(partitioner根据partition key计算获得)值范围是0到100, 那么这4个节点对应的token分别为0,25,50,75。这样确保了每个节点含有范围相等(data range都是25)的数据, 节点1分配token 0, 对应token range[0, 25);节点2分配token 25, 对应token range[25, 50); 节点3分配token 50, 对应token range[50, 75); 节点4分配token 75, 对应token range[75, 100);<br><strong>1.2版本之后, 引入了vnode的概念. 实质是对数据环进行了更细粒度(at a finer granularity )的划分</strong>。一个节点从之前的只被分配到一个token 变成了 被分配到多个token。这样一个节点含有多个token值，每个token同样对应的是一段连续范围内的数据, 但是多个token之间对应的数据范围可能是不连续的。<br><a href="https://docs.datastax.com/en/archived/cassandra/3.x/cassandra/architecture/archDataDistributeVnodesUsing.html" target="_blank" rel="noopener">关于vnode的主要作用：Vnodes simplify many tasks in Cassandra</a>, 这里也附上<a href="https://www.datastax.com/dev/blog/virtual-nodes-in-cassandra-1-2" target="_blank" rel="noopener">datastax对vnode的说明</a>:<br>Tokens are automatically calculated and assigned to each node.<br>token自动计算产生，并分配给每个节点<br>Rebalancing a cluster is automatically accomplished when adding or removing nodes. When a node joins the cluster, it assumes responsibility for an even portion of data from the other nodes in the cluster. If a node fails, the load is spread evenly across other nodes in the cluster.<br>集群添加或删除节点上, 能够更快地进行rebalacne, 完成数据迁移<br>Rebuilding a dead node is faster because it involves every other node in the cluster.<br>故障节点恢复时会更快完成构建<br>The proportion of vnodes assigned to each machine in a cluster can be assigned, so smaller and larger computers can be used in building a cluster.<br>每个机器节点含有的vnode个数是可以调整分配的, 因此在构建集群过程中, 配置较低或者配置较高的机器都可使用(适当调整配置文件中的vnode个数)</p>
<p>上图中的数据环第二部分, 表示的是含有vnode节点的集群。Starting in version 1.2, Cassandra allows many tokens per node. The new paradigm is called virtual nodes (vnodes). Vnodes allow each node to own a large number of small partition ranges distributed throughout the cluster. Vnodes also use consistent hashing to distribute data but using them doesn’t require token generation and assignment. The bottom portion of the graphic shows a ring with vnodes. Within a cluster, virtual nodes are randomly selected and non-contiguous. The placement of a row is determined by the hash of the partition key within many smaller partition ranges belonging to each node. 1.2版本之后, 引入vnode, 允许一个节点含有多个token。vnode使得每个节点拥有多个小的分区范围(内的数据), 它使用一致性hash将数据分布式存储, 并且不需要(手动)token生成和分配。 图中的第二部分表示的是一个含有vnode的数据环。在集群内部, (节点含有的)vnode是随机选择的,并且(节点含有的vnode之间的数据范围可能)是不连续的。一行数据的存储位置(placement)是由其partition key对应的hash值决定的, (根据该hash值)将数据放置在含有多个小的分区范围的某个节点上。  </p>
<p><a href="https://docs.datastax.com/en/archived/cassandra/3.x/cassandra/architecture/archDataDistributeHashing.html" target="_blank" rel="noopener">解释一下一致性hash:consistent hashing</a>: Consistent hashing allows distribution of data across a cluster to minimize reorganization when nodes are added or removed. 一致性hash考虑的是当数据分布式存储在集群上,添加或删除节点时, 最小化数据重组(就是说尽量减少数据rebalance, 即数据在多个节点之前迁移的开销)。  </p>
<p><a href="https://stackoverflow.com/questions/37940630/cassandra-vnodes-and-token-ranges" target="_blank" rel="noopener">关于每个节点对应的vnode如何产生, stackoverflow这里似乎有个解释</a>:Every partition key in Cassandra is converted to a numerical token value using the MurMur3 hash function. The token range is between -2^63 to +2^63 num_token defines how many token ranges are assigned to a node. Each node calculates 256 (num_tokens) random values in the token range and informs other nodes what they are, thus when a node needs to coordinate a request for a specific token it knows which nodes are responsible for it, according to the Replication Factor and DC/rack placement. A better description for this feature would be “automatic token range assignment for better streaming capabilities”, calling it “virtual” is a bit confusing. If you have 6 nodes, each set with 256 token ranges so you have 6*256 token ranges and each psychical node contains 256 token ranges. 默认通过Murmur3Partitioner获取到partition key对应的hash值. 每个节点在token对应的范围内，计算得到256个随机token值，并且告知其他节点(自己含有哪些token)，这样，当一个节点需要协调处理某个指定token(partitioner计算得到的值)对应的请求时, 它就会结合副本策略和DC/rack位置，知道哪些节点应该负责(含有副本数据的节点处理对应请求)。一个6节点集群, num_tokens设置为256，每个节点会有256个token值，每个节点对应存储的是256个token范围内的数据。For example consider 2 nodes with num_tokens set to 4 and token range 0 to 100. Node 1 calculates tokens 17, 35, 77, 92 Node 2 calculates tokens 4, 25, 68, 85 The ring shows the distribution of token ranges in this case Node 2 is responsible for token ranges 4-17, 25-35, 68-77, 85-92 and node 1 for the rest. 这里举例的是2个节点的集群, num_token设置为4.  </p>
<p>实例图中的vnode个数是8个(包含副本)，Cassandra3.9 vnode默认是256个，可以设置num_tokens改变。 通过command:  nodetool  ring可以查看节点含有哪些vnode.  </p>
<p><strong>partition key计算得到的是一个token值, 相同partition key对应的多行数据(一个列族中的多行)底层实际存储为一行数据(类似于一个很宽的行)。当对应行的token值落在某个token range时, 就将该行数据存储在token range对应的某个节点上，这个token range是一个连续token范围内的数据, 其实就是对应一个vnode. 因此这样来说, 一个vnode相当于一个分区(hbase中的一个region, 或者elasticsearch中的一个分片)。</strong><a href="https://stackoverflow.com/questions/30648479/choosing-a-partition-key-for-a-cassandra-table-how-many-is-too-many-partition" target="_blank" rel="noopener">stackoverflow中有人对partition这样做了解释,说明了这一点</a>：The recommended partitioner takes your partition key values and then computes a 128 bit hash from them. The hash is called the token of the record, and it is that token value that determines where your record is stored. Each Cassandra node has a set of token ranges associated with it. If the token of a record falls with a range of a node, the record is stored on that node. The number of partitions is not determined by your choice of partition key: it is the number of token ranges in your cluster. That is roughly equal to the total number of vnodes you selected when you configured your data store nodes. 作者最后说到, partition的个数并不是由partition key决定的, 而是由集群中的token range的数目决定的, (每个节点的partition个数)等于集群配置中的vnode个数。  </p>
<p>在含有三个节点的生产集群上, num_tokens为256, 使用nodetool ring – gps 查看keyspace为gps的token分布情况，发现总共含有token个数为256*3, 每个节点含有256个token. token分布情况截图如下：<img src="/Users/zhouqingfeng/Desktop/myDirect/github/distributedStudy/nosql/cassandra/token%E5%88%86%E5%B8%83.png" alt="token分布情况">  </p>
<h2 id="内部数据存储-包含-lsm-tree-Log-Structured-Merge-Tree-、memtable、-sstable、-commitlog等"><a href="#内部数据存储-包含-lsm-tree-Log-Structured-Merge-Tree-、memtable、-sstable、-commitlog等" class="headerlink" title="内部数据存储(包含 lsm tree(Log-Structured Merge Tree)、memtable、 sstable、 commitlog等)"></a>内部数据存储(包含 lsm tree(Log-Structured Merge Tree)、memtable、 sstable、 commitlog等)</h2><h3 id="数据读写"><a href="#数据读写" class="headerlink" title="数据读写"></a>数据读写</h3><h3 id="节点处理客户端读写请求："><a href="#节点处理客户端读写请求：" class="headerlink" title="节点处理客户端读写请求："></a>节点处理客户端读写请求：</h3><p>All nodes in Cassandra are peers. A client read or write request can go to any node in the cluster. When a client connects to a node and issues a read or write request, that node serves as the coordinator for that particular client operation.</p>
<p>The job of the coordinator is to act as a proxy between the client application and the nodes (or replicas) that own the data being requested. The coordinator determines which nodes in the ring should get the request based on the cluster configured partitioner and replica placement strategy.</p>
<h2 id="节点通信"><a href="#节点通信" class="headerlink" title="节点通信"></a>节点通信</h2><p>使用gossip协议进行通信。</p>
<h2 id="副本机制"><a href="#副本机制" class="headerlink" title="副本机制"></a>副本机制</h2><h2 id="Cassandra优化："><a href="#Cassandra优化：" class="headerlink" title="Cassandra优化："></a>Cassandra优化：</h2><p><a href="https://docs.datastax.com/en/archived/cassandra/3.x/cassandra/dml/dmlHowDataMaintain.html?hl=compaction%2Cstrategy" target="_blank" rel="noopener"><strong>数据compaction策略</strong></a><br>SizeTieredCompactionStrategy (STCS)  -&gt; TimeWindowCompactionStrategy (TWCS)  </p>
<p><a href="https://docs.datastax.com/en/cassandra/3.0/cassandra/operations/opsTuneJVM.html" target="_blank" rel="noopener"><strong>GC优化</strong></a><br>CMS -&gt; G1  heapsize调整为-Xms32G  -Xmx32G</p>
<p><strong>Partition key调整</strong>：imei -&gt; imei + date(<strong>注意: 特别重要</strong>)  </p>
<p><strong>其他优化策略</strong><br>文件cache大小：file_cache_size_in_mb: 512  -&gt;  2048<br>压实操作每秒的吞吐量：compaction_throughput_mb_per_sec: 16  -&gt;  32<br>compact并发操作的compactor个数：concurrent_compactors: 1  -&gt;  6</p>
<h2 id="Some-Questions"><a href="#Some-Questions" class="headerlink" title="Some Questions:"></a>Some Questions:</h2><ol>
<li><p>cassandra是否同hbase一样, 满足列式存储？(不是严格意义上的列式存储, 应该说都是按列族存储(前文wide column store中已详细阐述)  </p>
</li>
<li><p>cassandra数据写入如何保证有序性？ sstable、memtable都是有序的？  </p>
</li>
<li><p><a href="https://opensourceconnections.com/blog/2013/07/24/understanding-how-cql3-maps-to-cassandras-internal-data-structure/" target="_blank" rel="noopener">How CQL3 Maps to Cassandra’s Internal Data Structure</a>   </p>
</li>
<li><p><a href="https://blog.knoldus.com/2016/10/18/cassandra-data-modeling-primary-clustering-partition-compound-keys/" target="_blank" rel="noopener">the difference between Primary , Clustering , Partition , Compound Keys</a>  </p>
</li>
<li><p>What is a seed node in Apache Cassandra?  </p>
</li>
<li><p>dd</p>
</li>
</ol>
<p><strong>问题3部分摘取：</strong><br><strong>结论：一个table(column family)含有相同partition key的多行(row)数据底层实际存储为一个大的行</strong><br>CREATE TABLE tweets (<br>        … user text,<br>        … time timestamp,<br>        … tweet text,<br>        … lat float,<br>        … long float,<br>        … PRIMARY KEY (user, time)<br>        … );<br>cqlsh:test&gt; SELECT * FROM tweets;<br> user         | time                     | lat    | long    | tweet<br>————–+————————–+——–+———+———————<br> softwaredoug | 2013-07-13 08:21:54-0400 | 38.162 | -78.549 |  Having chest pain.<br> softwaredoug | 2013-07-21 12:15:27-0400 | 38.093 | -78.573 |   Speedo self shot.<br>      jnbrymn | 2013-06-29 20:53:15-0400 | 38.092 | -78.453 | I like programming.<br>      jnbrymn | 2013-07-14 22:55:45-0400 | 38.073 | -78.659 |     Who likes cats?<br>      jnbrymn | 2013-07-24 06:23:54-0400 | 38.073 | -78.647 |  My coffee is cold.  </p>
<p>[default@test] list tweets;</p>
<p>RowKey: softwaredoug<br>=&gt; (column=2013-07-13 08:21:54-0400:, value=, timestamp=1374673155373000)<br>=&gt; (column=2013-07-13 08:21:54-0400:lat, value=4218a5e3, timestamp=1374673155373000)<br>=&gt; (column=2013-07-13 08:21:54-0400:long, value=c29d1917, timestamp=1374673155373000)<br>=&gt; (column=2013-07-13 08:21:54-0400:tweet, value=486176696e67206368657374207061696e2e, timestamp=1374673155373000)<br>=&gt; (column=2013-07-21 12:15:27-0400:, value=, timestamp=1374673155407000)<br>=&gt; (column=2013-07-21 12:15:27-0400:lat, value=42185f3b, timestamp=1374673155407000)<br>=&gt; (column=2013-07-21 12:15:27-0400:long, value=c29d2560, timestamp=1374673155407000)<br>=&gt; (column=2013-07-21 12:15:27-0400:tweet, value=53706565646f2073656c662073686f742e, timestamp=1374673155407000)</p>
<p>RowKey: jnbrymn<br>=&gt; (column=2013-06-29 20:53:15-0400:, value=, timestamp=1374673155419000)<br>=&gt; (column=2013-06-29 20:53:15-0400:lat, value=42185e35, timestamp=1374673155419000)<br>=&gt; (column=2013-06-29 20:53:15-0400:long, value=c29ce7f0, timestamp=1374673155419000)<br>=&gt; (column=2013-06-29 20:53:15-0400:tweet, value=49206c696b652070726f6772616d6d696e672e, timestamp=1374673155419000)<br>=&gt; (column=2013-07-14 22:55:45-0400:, value=, timestamp=1374673155434000)<br>=&gt; (column=2013-07-14 22:55:45-0400:lat, value=42184ac1, timestamp=1374673155434000)<br>=&gt; (column=2013-07-14 22:55:45-0400:long, value=c29d5168, timestamp=1374673155434000)<br>=&gt; (column=2013-07-14 22:55:45-0400:tweet, value=57686f206c696b657320636174733f, timestamp=1374673155434000)<br>=&gt; (column=2013-07-24 06:23:54-0400:, value=, timestamp=1374673155485000)<br>=&gt; (column=2013-07-24 06:23:54-0400:lat, value=42184ac1, timestamp=1374673155485000)<br>=&gt; (column=2013-07-24 06:23:54-0400:long, value=c29d4b44, timestamp=1374673155485000)<br>=&gt; (column=2013-07-24 06:23:54-0400:tweet, value=4d7920636f6666656520697320636f6c642e, timestamp=1374673155485000)</p>
<p>We see here that internally in Cassandra, these tweets are stored in two different rows. The internal rows are keyed by the user names — the partition keys. This is why it is so efficient to retrieve all the tweets for a single user. The internal columns are named by the tweet times — the clustering keys.  </p>
<p><strong>问题4部分摘取：</strong><br><a href="https://blog.knoldus.com/2016/10/18/cassandra-data-modeling-primary-clustering-partition-compound-keys/" target="_blank" rel="noopener">the difference between Primary , Clustering , Partition , Compound Keys</a><br>作者这里也详细解释了<strong>parititon key的作用：</strong>The purpose of *<em>partition key is to identify the partition or node in the cluster which stores that row. *</em>When data is read or write from the cluster a function called Partitioner is used to compute the hash value of the partition key. This hash value is used to determine the node/partition which contains that row. For example rows whose partition key values range from 1000 to 1234 may reside in node A and rows with partition key values range from 1235 to 2000 may reside in node B as shown in figure 1. If a row contains partition key whose hash value is 1233 then it will be stored in node A.  </p>
<p><strong>cluster key的作用：</strong>The purpose of clustering key is to store row data in sorted order.<br>这里的example:<br>create keyspace Students_Details with replication = {‘class’ : ‘SimpleStrategy’, ‘replication_factor’:1};<br>create table student (stuid int, avg_marks float, description text, primary key (stuid));<br>Enabling the expand command<br>cqlsh:students_details&gt; EXPAND ON<br>create table marks(stuid int,exam_date timestamp,marks float,exam_name text , primary key (stuid,exam_date));<br>Add some data into the table:</p>
<p>insert into marks(stuid ,exam_date ,marks ,exam_name) values (1,’2016-11-10′,76 ,’examA’);<br>insert into marks(stuid ,exam_date ,marks ,exam_name) values (1,’2016-11-11′,90 ,’examB’);<br>insert into marks(stuid ,exam_date ,marks ,exam_name) values (1,’2016-11-12′,68 ,’examC’);</p>
<p>select token(stuid) from marks;</p>
<p>@ Row 1<br>———————+———————-<br>system.token(stuid) | -4069959284402364209</p>
<p>@ Row 2<br>———————+———————-<br>system.token(stuid) | -4069959284402364209</p>
<p>@ Row 3<br>———————+———————-<br>system.token(stuid) | -4069959284402364209<br>We can see all the three rows have same partition token , hence Cassandra stores only one row for each partition key. All the data associated to that partition key is stored as columns in the datastore. The data which we have stored through three different insert statements have the same stuid value i.e. 1 therefore all the data is saved in that row as columns , i.e under one partition . 这里插入了三行数据，由于partition key相同(对应的token相同), 因此这三行数据底层实际存储为一行数据, 结合<strong>问题3</strong>, 其他列对应的数据都按照cluster key(exam_date)分组、排序存储。</p>
<p>If you remember we discussed before that the second component of a primary key is called clustering key. The role of clustering key is to group related items together. All the data which is inserted against same clustering key is grouped together. (clustering key会将列分组排序, 含有相同clustering key的数据被放在一组)  </p>
<p><strong>问题5解释：</strong><br><a href="https://docs.datastax.com/en/archived/cassandra/3.x/cassandra/architecture/archGossipAbout.html?hl=seed%2Cnodes" target="_blank" rel="noopener">来自datastax的回答</a><br>Gossip is a peer-to-peer communication protocol in which nodes periodically exchange state information about themselves and about other nodes they know about. The gossip process runs every second and exchanges state messages with up to three other nodes in the cluster. The nodes exchange information about themselves and about the other nodes that they have gossiped about, so all nodes quickly learn about all other nodes in the cluster. A gossip message has a version associated with it, so that during a gossip exchange, older information is overwritten with the most current state for a particular node.<br>主要是对gossip协议进行了解释。</p>
<p>To prevent problems in gossip communications, use the same list of seed nodes for all nodes in a cluster. This is most critical the first time a node starts up. By default, a node remembers other nodes it has gossiped with between subsequent restarts. <strong>The seed node designation has no purpose other than bootstrapping the gossip process for new nodes joining the cluster. Seed nodes are not a single point of failure, nor do they have any other special purpose in cluster operations beyond the bootstrapping of nodes.</strong> (种子节点的作用仅仅是 对加入集群的新节点引导gossip进程。种子节点即不是用于单点故障(后的恢复), 也不是用于集群操作的其它目的, 仅仅用于节点的启动引导。<strong>简单可以理解为, 对种子节点来说,其作用仅仅是引导新的节点第一次启动时加入集群。因为节点之间是对等的关系, 新节点第一次启动时,并不知道集群中其他节点的位置和状态, 新节点上的gossip进程启动后, 必须要通过gossip协议发送消息和种子节点进行通信才能获取到集群的状态(包括其他节点的位置和状态等信息)</strong> )<br><a href="https://www.quora.com/What-is-a-seed-node-in-Apache-Cassandra" target="_blank" rel="noopener">来自quora的解释, 有部分未看懂</a>；<br><a href="https://stackoverflow.com/questions/10407072/cassandra-seed-nodes-and-clients-connecting-to-nodes" target="_blank" rel="noopener">stackoverflow的解释</a>:Seeds are used during startup to discover the cluster.（节点第一次启动时发现集群）  </p>
<h2 id="others"><a href="#others" class="headerlink" title="others"></a>others</h2><p>暂时写到这，花点时间要好好整理一下，感觉好像有点意思了  </p>
<h2 id="reference-docs"><a href="#reference-docs" class="headerlink" title="reference docs"></a>reference docs</h2><p><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-apache-cassandra3x4/index.html" target="_blank" rel="noopener">IBM developWorks: Cassandra数据写入过程以及如何实现节点间数据同步</a><br><a href="https://github.com/apache/cassandra" target="_blank" rel="noopener">github项目地址</a><br><a href="https://en.wikipedia.org/wiki/Apache_Cassandra" target="_blank" rel="noopener">wiki地址</a><br><a href="https://www.jianshu.com/p/ceff9750ab60" target="_blank" rel="noopener">简书上的一篇文章:为什么选用cassandra, 主要有三点:扩展方便、弹性模式(可方便删除添加列)、高写入性能</a><br><a href="https://docs.datastax.com/en/archived/cassandra/3.x/" target="_blank" rel="noopener">datastax3.x的Cassandra文档</a>  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/01/nosql/cassandra/cassandraIntroduction2/" data-id="ckawbrweu0000d89a9n3r8as4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2020/05/31/nosql/hbase/HBase%E6%A6%82%E8%A7%88/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">HBase概览</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/nosql-cassandra/">nosql/cassandra/</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/nosql-hbase/">nosql/hbase/</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/01/nosql/cassandra/cassandraIntroduction2/">cassandraIntroduction2</a>
          </li>
        
          <li>
            <a href="/2020/05/31/nosql/hbase/HBase%E6%A6%82%E8%A7%88/">HBase概览</a>
          </li>
        
          <li>
            <a href="/2020/05/31/nosql/cassandra/cassandra%E6%A6%82%E8%A7%88/">cassandra概览</a>
          </li>
        
          <li>
            <a href="/2020/05/31/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>